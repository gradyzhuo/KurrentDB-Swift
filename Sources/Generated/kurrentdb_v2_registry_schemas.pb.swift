// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kurrentdb/v2/registry/schemas.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Kurrentdb_Protocol_Registry_V2_SchemaDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var dataFormat: Kurrentdb_Protocol_Registry_V2_SchemaDataFormat = .unspecified

  package var compatibility: Kurrentdb_Protocol_Registry_V2_CompatibilityMode = .unspecified

  package var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  package var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  package mutating func clearDescription_p() {self._description_p = nil}

  package var tags: Dictionary<String,String> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _description_p: String? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_CreateSchemaRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var details: Kurrentdb_Protocol_Registry_V2_SchemaDetails {
    get {return _details ?? Kurrentdb_Protocol_Registry_V2_SchemaDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  package var schemaDefinition: Data {
    get {return _schemaDefinition ?? Data()}
    set {_schemaDefinition = newValue}
  }
  /// Returns true if `schemaDefinition` has been explicitly set.
  package var hasSchemaDefinition: Bool {return self._schemaDefinition != nil}
  /// Clears the value of `schemaDefinition`. Subsequent reads from it will return its default value.
  package mutating func clearSchemaDefinition() {self._schemaDefinition = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Kurrentdb_Protocol_Registry_V2_SchemaDetails? = nil
  fileprivate var _schemaDefinition: Data? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_CreateSchemaResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaVersionID: String = String()

  package var versionNumber: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_UpdateSchemaRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the schema to update.
  package var schemaName: String = String()

  /// description and tags only
  package var details: Kurrentdb_Protocol_Registry_V2_SchemaDetails {
    get {return _details ?? Kurrentdb_Protocol_Registry_V2_SchemaDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// Specifies which fields to update. See https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
  package var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  package var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateMask() {self._updateMask = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Kurrentdb_Protocol_Registry_V2_SchemaDetails? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_UpdateSchemaResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_DeleteSchemaRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_DeleteSchemaResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_Schema: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var details: Kurrentdb_Protocol_Registry_V2_SchemaDetails {
    get {return _details ?? Kurrentdb_Protocol_Registry_V2_SchemaDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  package var latestSchemaVersion: Int32 = 0

  package var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  package var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedAt() {self._createdAt = nil}

  package var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  package var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  package mutating func clearUpdatedAt() {self._updatedAt = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Kurrentdb_Protocol_Registry_V2_SchemaDetails? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_GetSchemaRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_GetSchemaResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schema: Kurrentdb_Protocol_Registry_V2_Schema {
    get {return _schema ?? Kurrentdb_Protocol_Registry_V2_Schema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  package var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  package mutating func clearSchema() {self._schema = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _schema: Kurrentdb_Protocol_Registry_V2_Schema? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_ListSchemasRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The prefix of the schema name. If specified, only schemas with the specified prefix are returned.
  package var schemaNamePrefix: String {
    get {return _schemaNamePrefix ?? String()}
    set {_schemaNamePrefix = newValue}
  }
  /// Returns true if `schemaNamePrefix` has been explicitly set.
  package var hasSchemaNamePrefix: Bool {return self._schemaNamePrefix != nil}
  /// Clears the value of `schemaNamePrefix`. Subsequent reads from it will return its default value.
  package mutating func clearSchemaNamePrefix() {self._schemaNamePrefix = nil}

  /// The tags to filter the schemas. If specified, only schemas with the specified tags are returned.
  package var schemaTags: Dictionary<String,String> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _schemaNamePrefix: String? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_ListSchemasResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemas: [Kurrentdb_Protocol_Registry_V2_Schema] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_LookupSchemaNameRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaVersionID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_LookupSchemaNameResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_RegisterSchemaVersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var schemaDefinition: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_RegisterSchemaVersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaVersionID: String = String()

  package var versionNumber: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var versions: [Int32] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var errors: [Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse.SchemaVersionError] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct SchemaVersionError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ErrorDetails error          = 2;
    package var versionNumber: Int32 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_SchemaVersion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaVersionID: String = String()

  package var versionNumber: Int32 = 0

  package var schemaDefinition: Data = Data()

  package var dataFormat: Kurrentdb_Protocol_Registry_V2_SchemaDataFormat = .unspecified

  package var registeredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _registeredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_registeredAt = newValue}
  }
  /// Returns true if `registeredAt` has been explicitly set.
  package var hasRegisteredAt: Bool {return self._registeredAt != nil}
  /// Clears the value of `registeredAt`. Subsequent reads from it will return its default value.
  package mutating func clearRegisteredAt() {self._registeredAt = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _registeredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_GetSchemaVersionByIdRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaVersionID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_GetSchemaVersionByIdResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var version: Kurrentdb_Protocol_Registry_V2_SchemaVersion {
    get {return _version ?? Kurrentdb_Protocol_Registry_V2_SchemaVersion()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  package var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  package mutating func clearVersion() {self._version = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _version: Kurrentdb_Protocol_Registry_V2_SchemaVersion? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_GetSchemaVersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  /// without this field, the latest version will be returned
  package var versionNumber: Int32 {
    get {return _versionNumber ?? 0}
    set {_versionNumber = newValue}
  }
  /// Returns true if `versionNumber` has been explicitly set.
  package var hasVersionNumber: Bool {return self._versionNumber != nil}
  /// Clears the value of `versionNumber`. Subsequent reads from it will return its default value.
  package mutating func clearVersionNumber() {self._versionNumber = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _versionNumber: Int32? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_GetSchemaVersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var version: Kurrentdb_Protocol_Registry_V2_SchemaVersion {
    get {return _version ?? Kurrentdb_Protocol_Registry_V2_SchemaVersion()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  package var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  package mutating func clearVersion() {self._version = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _version: Kurrentdb_Protocol_Registry_V2_SchemaVersion? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_ListSchemaVersionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var includeDefinition: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_ListSchemaVersionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var versions: [Kurrentdb_Protocol_Registry_V2_SchemaVersion] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// This message represents the latest registered schema version for a specific schema.
package struct Kurrentdb_Protocol_Registry_V2_RegisteredSchema: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemaName: String = String()

  package var schemaVersionID: String = String()

  package var versionNumber: Int32 = 0

  package var schemaDefinition: Data = Data()

  package var dataFormat: Kurrentdb_Protocol_Registry_V2_SchemaDataFormat = .unspecified

  package var compatibility: Kurrentdb_Protocol_Registry_V2_CompatibilityMode = .unspecified

  package var tags: Dictionary<String,String> = [:]

  package var registeredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _registeredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_registeredAt = newValue}
  }
  /// Returns true if `registeredAt` has been explicitly set.
  package var hasRegisteredAt: Bool {return self._registeredAt != nil}
  /// Clears the value of `registeredAt`. Subsequent reads from it will return its default value.
  package mutating func clearRegisteredAt() {self._registeredAt = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _registeredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// This message is used to request a list of registered schemas.
package struct Kurrentdb_Protocol_Registry_V2_ListRegisteredSchemasRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique identifier of the schema version. If specified, only the schema with the specified version ID is
  /// returned.
  package var schemaVersionID: String {
    get {return _schemaVersionID ?? String()}
    set {_schemaVersionID = newValue}
  }
  /// Returns true if `schemaVersionID` has been explicitly set.
  package var hasSchemaVersionID: Bool {return self._schemaVersionID != nil}
  /// Clears the value of `schemaVersionID`. Subsequent reads from it will return its default value.
  package mutating func clearSchemaVersionID() {self._schemaVersionID = nil}

  /// The prefix of the schema name. If specified, only schemas with the specified prefix are returned.
  package var schemaNamePrefix: String {
    get {return _schemaNamePrefix ?? String()}
    set {_schemaNamePrefix = newValue}
  }
  /// Returns true if `schemaNamePrefix` has been explicitly set.
  package var hasSchemaNamePrefix: Bool {return self._schemaNamePrefix != nil}
  /// Clears the value of `schemaNamePrefix`. Subsequent reads from it will return its default value.
  package mutating func clearSchemaNamePrefix() {self._schemaNamePrefix = nil}

  /// The tags to filter the schemas. If specified, only schemas with the specified tags are returned.
  package var schemaTags: Dictionary<String,String> = [:]

  /// If true, the schema definition will be included in the response.
  package var includeDefinition: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _schemaVersionID: String? = nil
  fileprivate var _schemaNamePrefix: String? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_ListRegisteredSchemasResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schemas: [Kurrentdb_Protocol_Registry_V2_RegisteredSchema] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_BulkRegisterSchemasRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var requests: [Kurrentdb_Protocol_Registry_V2_CreateSchemaRequest] = []

  package var keepOrder: Bool = false

  package var stopOnError: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_BulkRegisterSchemasResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  package var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  package mutating func clearDuration() {self._duration = nil}

  package var responses: [Kurrentdb_Protocol_Registry_V2_CreateSchemaResponse] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kurrentdb.protocol.registry.v2"

extension Kurrentdb_Protocol_Registry_V2_SchemaDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SchemaDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}data_format\0\u{1}compatibility\0\u{1}description\0\u{1}tags\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dataFormat) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.compatibility) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.dataFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.dataFormat, fieldNumber: 1)
    }
    if self.compatibility != .unspecified {
      try visitor.visitSingularEnumField(value: self.compatibility, fieldNumber: 2)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_SchemaDetails, rhs: Kurrentdb_Protocol_Registry_V2_SchemaDetails) -> Bool {
    if lhs.dataFormat != rhs.dataFormat {return false}
    if lhs.compatibility != rhs.compatibility {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_CreateSchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateSchemaRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0\u{1}details\0\u{3}schema_definition\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._schemaDefinition) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._schemaDefinition {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_CreateSchemaRequest, rhs: Kurrentdb_Protocol_Registry_V2_CreateSchemaRequest) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs._details != rhs._details {return false}
    if lhs._schemaDefinition != rhs._schemaDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_CreateSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateSchemaResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_version_id\0\u{3}version_number\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaVersionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.versionNumber) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaVersionID, fieldNumber: 1)
    }
    if self.versionNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.versionNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_CreateSchemaResponse, rhs: Kurrentdb_Protocol_Registry_V2_CreateSchemaResponse) -> Bool {
    if lhs.schemaVersionID != rhs.schemaVersionID {return false}
    if lhs.versionNumber != rhs.versionNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_UpdateSchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateSchemaRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0\u{1}details\0\u{3}update_mask\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_UpdateSchemaRequest, rhs: Kurrentdb_Protocol_Registry_V2_UpdateSchemaRequest) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs._details != rhs._details {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_UpdateSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateSchemaResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_UpdateSchemaResponse, rhs: Kurrentdb_Protocol_Registry_V2_UpdateSchemaResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_DeleteSchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteSchemaRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaRequest, rhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaRequest) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_DeleteSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteSchemaResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaResponse, rhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_Schema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Schema"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0\u{1}details\0\u{4}\u{2}latest_schema_version\0\u{3}created_at\0\u{3}updated_at\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.latestSchemaVersion) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.latestSchemaVersion != 0 {
      try visitor.visitSingularInt32Field(value: self.latestSchemaVersion, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_Schema, rhs: Kurrentdb_Protocol_Registry_V2_Schema) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs._details != rhs._details {return false}
    if lhs.latestSchemaVersion != rhs.latestSchemaVersion {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_GetSchemaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSchemaRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_GetSchemaRequest, rhs: Kurrentdb_Protocol_Registry_V2_GetSchemaRequest) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_GetSchemaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSchemaResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schema\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_GetSchemaResponse, rhs: Kurrentdb_Protocol_Registry_V2_GetSchemaResponse) -> Bool {
    if lhs._schema != rhs._schema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ListSchemasRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSchemasRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name_prefix\0\u{3}schema_tags\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._schemaNamePrefix) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.schemaTags) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._schemaNamePrefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.schemaTags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.schemaTags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ListSchemasRequest, rhs: Kurrentdb_Protocol_Registry_V2_ListSchemasRequest) -> Bool {
    if lhs._schemaNamePrefix != rhs._schemaNamePrefix {return false}
    if lhs.schemaTags != rhs.schemaTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ListSchemasResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSchemasResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schemas\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.schemas) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.schemas, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ListSchemasResponse, rhs: Kurrentdb_Protocol_Registry_V2_ListSchemasResponse) -> Bool {
    if lhs.schemas != rhs.schemas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_LookupSchemaNameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".LookupSchemaNameRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_version_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaVersionID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaVersionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_LookupSchemaNameRequest, rhs: Kurrentdb_Protocol_Registry_V2_LookupSchemaNameRequest) -> Bool {
    if lhs.schemaVersionID != rhs.schemaVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_LookupSchemaNameResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".LookupSchemaNameResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_LookupSchemaNameResponse, rhs: Kurrentdb_Protocol_Registry_V2_LookupSchemaNameResponse) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_RegisterSchemaVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RegisterSchemaVersionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0\u{3}schema_definition\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.schemaDefinition) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    if !self.schemaDefinition.isEmpty {
      try visitor.visitSingularBytesField(value: self.schemaDefinition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_RegisterSchemaVersionRequest, rhs: Kurrentdb_Protocol_Registry_V2_RegisterSchemaVersionRequest) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.schemaDefinition != rhs.schemaDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_RegisterSchemaVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RegisterSchemaVersionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_version_id\0\u{3}version_number\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaVersionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.versionNumber) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaVersionID, fieldNumber: 1)
    }
    if self.versionNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.versionNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_RegisterSchemaVersionResponse, rhs: Kurrentdb_Protocol_Registry_V2_RegisterSchemaVersionResponse) -> Bool {
    if lhs.schemaVersionID != rhs.schemaVersionID {return false}
    if lhs.versionNumber != rhs.versionNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteSchemaVersionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0\u{1}versions\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.versions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    if !self.versions.isEmpty {
      try visitor.visitPackedInt32Field(value: self.versions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsRequest, rhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsRequest) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.versions != rhs.versions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteSchemaVersionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}errors\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse, rhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse) -> Bool {
    if lhs.errors != rhs.errors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse.SchemaVersionError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse.protoMessageName + ".SchemaVersionError"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}version_number\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.versionNumber) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.versionNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.versionNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse.SchemaVersionError, rhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaVersionsResponse.SchemaVersionError) -> Bool {
    if lhs.versionNumber != rhs.versionNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_SchemaVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SchemaVersion"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_version_id\0\u{3}version_number\0\u{3}schema_definition\0\u{3}data_format\0\u{3}registered_at\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaVersionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.versionNumber) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.schemaDefinition) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.dataFormat) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._registeredAt) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.schemaVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaVersionID, fieldNumber: 1)
    }
    if self.versionNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.versionNumber, fieldNumber: 2)
    }
    if !self.schemaDefinition.isEmpty {
      try visitor.visitSingularBytesField(value: self.schemaDefinition, fieldNumber: 3)
    }
    if self.dataFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.dataFormat, fieldNumber: 4)
    }
    try { if let v = self._registeredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_SchemaVersion, rhs: Kurrentdb_Protocol_Registry_V2_SchemaVersion) -> Bool {
    if lhs.schemaVersionID != rhs.schemaVersionID {return false}
    if lhs.versionNumber != rhs.versionNumber {return false}
    if lhs.schemaDefinition != rhs.schemaDefinition {return false}
    if lhs.dataFormat != rhs.dataFormat {return false}
    if lhs._registeredAt != rhs._registeredAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_GetSchemaVersionByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSchemaVersionByIdRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_version_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaVersionID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaVersionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_GetSchemaVersionByIdRequest, rhs: Kurrentdb_Protocol_Registry_V2_GetSchemaVersionByIdRequest) -> Bool {
    if lhs.schemaVersionID != rhs.schemaVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_GetSchemaVersionByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSchemaVersionByIdResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_GetSchemaVersionByIdResponse, rhs: Kurrentdb_Protocol_Registry_V2_GetSchemaVersionByIdResponse) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_GetSchemaVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSchemaVersionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0\u{3}version_number\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._versionNumber) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    try { if let v = self._versionNumber {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_GetSchemaVersionRequest, rhs: Kurrentdb_Protocol_Registry_V2_GetSchemaVersionRequest) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs._versionNumber != rhs._versionNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_GetSchemaVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSchemaVersionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_GetSchemaVersionResponse, rhs: Kurrentdb_Protocol_Registry_V2_GetSchemaVersionResponse) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ListSchemaVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSchemaVersionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0\u{3}include_definition\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeDefinition) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    if self.includeDefinition != false {
      try visitor.visitSingularBoolField(value: self.includeDefinition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ListSchemaVersionsRequest, rhs: Kurrentdb_Protocol_Registry_V2_ListSchemaVersionsRequest) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.includeDefinition != rhs.includeDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ListSchemaVersionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSchemaVersionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}versions\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.versions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.versions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ListSchemaVersionsResponse, rhs: Kurrentdb_Protocol_Registry_V2_ListSchemaVersionsResponse) -> Bool {
    if lhs.versions != rhs.versions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_RegisteredSchema: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RegisteredSchema"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_name\0\u{3}schema_version_id\0\u{3}version_number\0\u{3}schema_definition\0\u{3}data_format\0\u{1}compatibility\0\u{1}tags\0\u{3}registered_at\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.schemaName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.schemaVersionID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.versionNumber) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.schemaDefinition) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.dataFormat) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.compatibility) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._registeredAt) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.schemaName.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaName, fieldNumber: 1)
    }
    if !self.schemaVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaVersionID, fieldNumber: 2)
    }
    if self.versionNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.versionNumber, fieldNumber: 3)
    }
    if !self.schemaDefinition.isEmpty {
      try visitor.visitSingularBytesField(value: self.schemaDefinition, fieldNumber: 4)
    }
    if self.dataFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.dataFormat, fieldNumber: 5)
    }
    if self.compatibility != .unspecified {
      try visitor.visitSingularEnumField(value: self.compatibility, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 7)
    }
    try { if let v = self._registeredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_RegisteredSchema, rhs: Kurrentdb_Protocol_Registry_V2_RegisteredSchema) -> Bool {
    if lhs.schemaName != rhs.schemaName {return false}
    if lhs.schemaVersionID != rhs.schemaVersionID {return false}
    if lhs.versionNumber != rhs.versionNumber {return false}
    if lhs.schemaDefinition != rhs.schemaDefinition {return false}
    if lhs.dataFormat != rhs.dataFormat {return false}
    if lhs.compatibility != rhs.compatibility {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._registeredAt != rhs._registeredAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ListRegisteredSchemasRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListRegisteredSchemasRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schema_version_id\0\u{3}schema_name_prefix\0\u{3}schema_tags\0\u{3}include_definition\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._schemaVersionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._schemaNamePrefix) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.schemaTags) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeDefinition) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._schemaVersionID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._schemaNamePrefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.schemaTags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.schemaTags, fieldNumber: 3)
    }
    if self.includeDefinition != false {
      try visitor.visitSingularBoolField(value: self.includeDefinition, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ListRegisteredSchemasRequest, rhs: Kurrentdb_Protocol_Registry_V2_ListRegisteredSchemasRequest) -> Bool {
    if lhs._schemaVersionID != rhs._schemaVersionID {return false}
    if lhs._schemaNamePrefix != rhs._schemaNamePrefix {return false}
    if lhs.schemaTags != rhs.schemaTags {return false}
    if lhs.includeDefinition != rhs.includeDefinition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ListRegisteredSchemasResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListRegisteredSchemasResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schemas\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.schemas) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schemas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.schemas, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ListRegisteredSchemasResponse, rhs: Kurrentdb_Protocol_Registry_V2_ListRegisteredSchemasResponse) -> Bool {
    if lhs.schemas != rhs.schemas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_BulkRegisterSchemasRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BulkRegisterSchemasRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requests\0\u{3}keep_order\0\u{3}stop_on_error\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requests) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.keepOrder) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.stopOnError) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    if self.keepOrder != false {
      try visitor.visitSingularBoolField(value: self.keepOrder, fieldNumber: 2)
    }
    if self.stopOnError != false {
      try visitor.visitSingularBoolField(value: self.stopOnError, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_BulkRegisterSchemasRequest, rhs: Kurrentdb_Protocol_Registry_V2_BulkRegisterSchemasRequest) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.keepOrder != rhs.keepOrder {return false}
    if lhs.stopOnError != rhs.stopOnError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_BulkRegisterSchemasResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BulkRegisterSchemasResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}duration\0\u{1}responses\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_BulkRegisterSchemasResponse, rhs: Kurrentdb_Protocol_Registry_V2_BulkRegisterSchemasResponse) -> Bool {
    if lhs._duration != rhs._duration {return false}
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
