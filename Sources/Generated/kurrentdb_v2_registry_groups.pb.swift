// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kurrentdb/v2/registry/groups.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package enum Kurrentdb_Protocol_Registry_V2_StreamFilterType: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case consumeFilterTypeUnspecified // = 0
  case consumeFilterTypeRegex // = 1
  case consumeFilterTypeCategory // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .consumeFilterTypeUnspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .consumeFilterTypeUnspecified
    case 1: self = .consumeFilterTypeRegex
    case 2: self = .consumeFilterTypeCategory
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .consumeFilterTypeUnspecified: return 0
    case .consumeFilterTypeRegex: return 1
    case .consumeFilterTypeCategory: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Kurrentdb_Protocol_Registry_V2_StreamFilterType] = [
    .consumeFilterTypeUnspecified,
    .consumeFilterTypeRegex,
    .consumeFilterTypeCategory,
  ]

}

package struct Kurrentdb_Protocol_Registry_V2_AutoRegistrationSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var enabled: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_ValidationSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var enabled: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_CompatibilitySettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var enforce: Bool = false

  package var mode: Kurrentdb_Protocol_Registry_V2_CompatibilityMode = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_DataFormatSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var enforce: Bool = false

  package var format: Kurrentdb_Protocol_Registry_V2_SchemaDataFormat = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_StreamFilter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var filterType: Kurrentdb_Protocol_Registry_V2_StreamFilterType = .consumeFilterTypeUnspecified

  package var expression: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Kurrentdb_Protocol_Registry_V2_StreamFilterSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var enforce: Bool = false

  package var filter: Kurrentdb_Protocol_Registry_V2_StreamFilter {
    get {return _filter ?? Kurrentdb_Protocol_Registry_V2_StreamFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  package var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  package mutating func clearFilter() {self._filter = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _filter: Kurrentdb_Protocol_Registry_V2_StreamFilter? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var name: String = String()

  package var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  package var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  package mutating func clearDescription_p() {self._description_p = nil}

  package var tags: Dictionary<String,String> = [:]

  /// Settings for automatic registration
  package var autoRegistration: Kurrentdb_Protocol_Registry_V2_AutoRegistrationSettings {
    get {return _autoRegistration ?? Kurrentdb_Protocol_Registry_V2_AutoRegistrationSettings()}
    set {_autoRegistration = newValue}
  }
  /// Returns true if `autoRegistration` has been explicitly set.
  package var hasAutoRegistration: Bool {return self._autoRegistration != nil}
  /// Clears the value of `autoRegistration`. Subsequent reads from it will return its default value.
  package mutating func clearAutoRegistration() {self._autoRegistration = nil}

  /// Settings for schema validation
  package var validation: Kurrentdb_Protocol_Registry_V2_ValidationSettings {
    get {return _validation ?? Kurrentdb_Protocol_Registry_V2_ValidationSettings()}
    set {_validation = newValue}
  }
  /// Returns true if `validation` has been explicitly set.
  package var hasValidation: Bool {return self._validation != nil}
  /// Clears the value of `validation`. Subsequent reads from it will return its default value.
  package mutating func clearValidation() {self._validation = nil}

  /// Settings for compatibility mode
  package var compatibility: Kurrentdb_Protocol_Registry_V2_CompatibilitySettings {
    get {return _compatibility ?? Kurrentdb_Protocol_Registry_V2_CompatibilitySettings()}
    set {_compatibility = newValue}
  }
  /// Returns true if `compatibility` has been explicitly set.
  package var hasCompatibility: Bool {return self._compatibility != nil}
  /// Clears the value of `compatibility`. Subsequent reads from it will return its default value.
  package mutating func clearCompatibility() {self._compatibility = nil}

  /// Settings for data format enforcement
  package var dataFormat: Kurrentdb_Protocol_Registry_V2_DataFormatSettings {
    get {return _dataFormat ?? Kurrentdb_Protocol_Registry_V2_DataFormatSettings()}
    set {_dataFormat = newValue}
  }
  /// Returns true if `dataFormat` has been explicitly set.
  package var hasDataFormat: Bool {return self._dataFormat != nil}
  /// Clears the value of `dataFormat`. Subsequent reads from it will return its default value.
  package mutating func clearDataFormat() {self._dataFormat = nil}

  /// Settings for stream filtering
  package var streamFilter: Kurrentdb_Protocol_Registry_V2_StreamFilterSettings {
    get {return _streamFilter ?? Kurrentdb_Protocol_Registry_V2_StreamFilterSettings()}
    set {_streamFilter = newValue}
  }
  /// Returns true if `streamFilter` has been explicitly set.
  package var hasStreamFilter: Bool {return self._streamFilter != nil}
  /// Clears the value of `streamFilter`. Subsequent reads from it will return its default value.
  package mutating func clearStreamFilter() {self._streamFilter = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _description_p: String? = nil
  fileprivate var _autoRegistration: Kurrentdb_Protocol_Registry_V2_AutoRegistrationSettings? = nil
  fileprivate var _validation: Kurrentdb_Protocol_Registry_V2_ValidationSettings? = nil
  fileprivate var _compatibility: Kurrentdb_Protocol_Registry_V2_CompatibilitySettings? = nil
  fileprivate var _dataFormat: Kurrentdb_Protocol_Registry_V2_DataFormatSettings? = nil
  fileprivate var _streamFilter: Kurrentdb_Protocol_Registry_V2_StreamFilterSettings? = nil
}

package struct Kurrentdb_Protocol_Registry_V2_SchemaGroup: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the schema group
  package var groupID: String {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  /// Details of the schema group
  package var details: Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails {
    get {return _storage._details ?? Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails()}
    set {_uniqueStorage()._details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return _storage._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {_uniqueStorage()._details = nil}

  package var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  package var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  package var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  package var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  package mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Command to create a new schema group with optional identifier and required configuration
package struct Kurrentdb_Protocol_Registry_V2_CreateSchemaGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the schema group
  package var groupID: String {
    get {return _groupID ?? String()}
    set {_groupID = newValue}
  }
  /// Returns true if `groupID` has been explicitly set.
  package var hasGroupID: Bool {return self._groupID != nil}
  /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
  package mutating func clearGroupID() {self._groupID = nil}

  /// Details of the schema group to be created
  package var details: Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails {
    get {return _details ?? Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _groupID: String? = nil
  fileprivate var _details: Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails? = nil
}

/// Response returned after successful schema group creation
package struct Kurrentdb_Protocol_Registry_V2_CreateSchemaGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the schema group
  package var groupID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Command to update an existing schema group's details with field masking support
package struct Kurrentdb_Protocol_Registry_V2_UpdateSchemaGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the schema group
  package var groupID: String = String()

  /// Details of the schema group to be updated
  package var details: Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails {
    get {return _details ?? Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// Specifies which fields to update. See https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
  package var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  package var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateMask() {self._updateMask = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Response returned after successful schema group details update
package struct Kurrentdb_Protocol_Registry_V2_UpdateSchemaGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Command to remove an existing schema group by identifier
package struct Kurrentdb_Protocol_Registry_V2_DeleteSchemaGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the schema group
  package var groupID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Empty response returned after successful schema group deletion
package struct Kurrentdb_Protocol_Registry_V2_DeleteSchemaGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Query to retrieve a specific schema group by identifier
package struct Kurrentdb_Protocol_Registry_V2_GetSchemaGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var groupID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Response containing the details of the requested schema group
package struct Kurrentdb_Protocol_Registry_V2_GetSchemaGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var group: Kurrentdb_Protocol_Registry_V2_SchemaGroup {
    get {return _group ?? Kurrentdb_Protocol_Registry_V2_SchemaGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  package var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  package mutating func clearGroup() {self._group = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _group: Kurrentdb_Protocol_Registry_V2_SchemaGroup? = nil
}

/// Query to list schema groups with optional name prefix filter
package struct Kurrentdb_Protocol_Registry_V2_ListSchemaGroupsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var groupNamePrefix: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _groupNamePrefix ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_groupNamePrefix = newValue}
  }
  /// Returns true if `groupNamePrefix` has been explicitly set.
  package var hasGroupNamePrefix: Bool {return self._groupNamePrefix != nil}
  /// Clears the value of `groupNamePrefix`. Subsequent reads from it will return its default value.
  package mutating func clearGroupNamePrefix() {self._groupNamePrefix = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _groupNamePrefix: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// Response containing a list of schema groups matching the query
package struct Kurrentdb_Protocol_Registry_V2_ListSchemaGroupsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var groups: [Kurrentdb_Protocol_Registry_V2_SchemaGroup] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kurrentdb.protocol.registry.v2"

extension Kurrentdb_Protocol_Registry_V2_StreamFilterType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CONSUME_FILTER_TYPE_UNSPECIFIED\0\u{1}CONSUME_FILTER_TYPE_REGEX\0\u{1}CONSUME_FILTER_TYPE_CATEGORY\0")
}

extension Kurrentdb_Protocol_Registry_V2_AutoRegistrationSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AutoRegistrationSettings"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_AutoRegistrationSettings, rhs: Kurrentdb_Protocol_Registry_V2_AutoRegistrationSettings) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ValidationSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ValidationSettings"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ValidationSettings, rhs: Kurrentdb_Protocol_Registry_V2_ValidationSettings) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_CompatibilitySettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompatibilitySettings"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enforce\0\u{1}mode\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enforce) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enforce != false {
      try visitor.visitSingularBoolField(value: self.enforce, fieldNumber: 1)
    }
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_CompatibilitySettings, rhs: Kurrentdb_Protocol_Registry_V2_CompatibilitySettings) -> Bool {
    if lhs.enforce != rhs.enforce {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_DataFormatSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DataFormatSettings"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enforce\0\u{1}format\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enforce) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enforce != false {
      try visitor.visitSingularBoolField(value: self.enforce, fieldNumber: 1)
    }
    if self.format != .unspecified {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_DataFormatSettings, rhs: Kurrentdb_Protocol_Registry_V2_DataFormatSettings) -> Bool {
    if lhs.enforce != rhs.enforce {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_StreamFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StreamFilter"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}filter_type\0\u{1}expression\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.filterType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.expression) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.filterType != .consumeFilterTypeUnspecified {
      try visitor.visitSingularEnumField(value: self.filterType, fieldNumber: 1)
    }
    if !self.expression.isEmpty {
      try visitor.visitSingularStringField(value: self.expression, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_StreamFilter, rhs: Kurrentdb_Protocol_Registry_V2_StreamFilter) -> Bool {
    if lhs.filterType != rhs.filterType {return false}
    if lhs.expression != rhs.expression {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_StreamFilterSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StreamFilterSettings"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enforce\0\u{1}filter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enforce) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enforce != false {
      try visitor.visitSingularBoolField(value: self.enforce, fieldNumber: 1)
    }
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_StreamFilterSettings, rhs: Kurrentdb_Protocol_Registry_V2_StreamFilterSettings) -> Bool {
    if lhs.enforce != rhs.enforce {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SchemaGroupDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}description\0\u{1}tags\0\u{4}\u{8}auto_registration\0\u{1}validation\0\u{1}compatibility\0\u{3}data_format\0\u{3}stream_filter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._autoRegistration) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._validation) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._compatibility) }()
      case 14: try { try decoder.decodeSingularMessageField(value: &self._dataFormat) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._streamFilter) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 3)
    }
    try { if let v = self._autoRegistration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._validation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._compatibility {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._dataFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._streamFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails, rhs: Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._autoRegistration != rhs._autoRegistration {return false}
    if lhs._validation != rhs._validation {return false}
    if lhs._compatibility != rhs._compatibility {return false}
    if lhs._dataFormat != rhs._dataFormat {return false}
    if lhs._streamFilter != rhs._streamFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_SchemaGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SchemaGroup"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}details\0\u{4}\u{3}created_at\0\u{3}updated_at\0")

  fileprivate class _StorageClass {
    var _groupID: String = String()
    var _details: Kurrentdb_Protocol_Registry_V2_SchemaGroupDetails? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _groupID = source._groupID
      _details = source._details
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._groupID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._details) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._groupID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupID, fieldNumber: 1)
      }
      try { if let v = _storage._details {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_SchemaGroup, rhs: Kurrentdb_Protocol_Registry_V2_SchemaGroup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_CreateSchemaGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateSchemaGroupRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_CreateSchemaGroupRequest, rhs: Kurrentdb_Protocol_Registry_V2_CreateSchemaGroupRequest) -> Bool {
    if lhs._groupID != rhs._groupID {return false}
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_CreateSchemaGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateSchemaGroupResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_CreateSchemaGroupResponse, rhs: Kurrentdb_Protocol_Registry_V2_CreateSchemaGroupResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_UpdateSchemaGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateSchemaGroupRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}details\0\u{3}update_mask\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_UpdateSchemaGroupRequest, rhs: Kurrentdb_Protocol_Registry_V2_UpdateSchemaGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._details != rhs._details {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_UpdateSchemaGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateSchemaGroupResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_UpdateSchemaGroupResponse, rhs: Kurrentdb_Protocol_Registry_V2_UpdateSchemaGroupResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_DeleteSchemaGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteSchemaGroupRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaGroupRequest, rhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_DeleteSchemaGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteSchemaGroupResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaGroupResponse, rhs: Kurrentdb_Protocol_Registry_V2_DeleteSchemaGroupResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_GetSchemaGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSchemaGroupRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_GetSchemaGroupRequest, rhs: Kurrentdb_Protocol_Registry_V2_GetSchemaGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_GetSchemaGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSchemaGroupResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}group\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_GetSchemaGroupResponse, rhs: Kurrentdb_Protocol_Registry_V2_GetSchemaGroupResponse) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ListSchemaGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSchemaGroupsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_name_prefix\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupNamePrefix) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupNamePrefix {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ListSchemaGroupsRequest, rhs: Kurrentdb_Protocol_Registry_V2_ListSchemaGroupsRequest) -> Bool {
    if lhs._groupNamePrefix != rhs._groupNamePrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_Registry_V2_ListSchemaGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSchemaGroupsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}groups\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_Registry_V2_ListSchemaGroupsResponse, rhs: Kurrentdb_Protocol_Registry_V2_ListSchemaGroupsResponse) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
