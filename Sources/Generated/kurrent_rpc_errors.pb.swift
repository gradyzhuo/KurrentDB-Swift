// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kurrent/rpc/errors.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ******************************************************************************************
// This protocol is UNSTABLE in the sense of being subject to change.
// ******************************************************************************************

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The canonical server error codes for the Kurrent Platform gRPC APIs.
/// These errors represent common failure modes across all Kurrent services.
package enum Kurrent_Rpc_ServerError: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Default value. This value is not used.
  /// An error code MUST always be set to a non-zero value.
  /// If an error code is not explicitly set, it MUST be treated as
  /// an internal server error (INTERNAL).
  case unspecified // = 0

  /// Authentication or authorization failure.
  /// The client lacks valid credentials or sufficient permissions to perform the requested operation.
  ///
  /// Common causes:
  /// - Missing or invalid authentication tokens
  /// - Insufficient permissions for the operation
  /// - Expired credentials
  ///
  /// Client action: Check credentials, verify permissions, and re-authenticate if necessary.
  /// Not retriable without fixing the underlying authorization issue.
  case accessDenied // = 1

  /// The request is malformed or contains invalid data.
  /// The server cannot process the request due to client error.
  ///
  /// Common causes:
  /// - Invalid field values (e.g., empty required fields, out-of-range numbers)
  /// - Malformed data formats
  /// - Validation failures
  ///
  /// Client action: Fix the request data and retry.
  /// Not retriable without modifying the request.
  case badRequest // = 2

  /// The server is not the cluster leader and cannot process write operations.
  /// In a clustered deployment, only the leader node can accept write operations.
  ///
  /// Common causes:
  /// - Client connected to a follower node
  /// - Leader election in progress
  /// - Network partition
  ///
  /// Client action: Redirect the request to the leader node indicated in the error details.
  /// Retriable after redirecting to the correct leader node.
  case notLeaderNode // = 5

  /// The operation did not complete within the configured timeout period.
  ///
  /// Common causes:
  /// - Slow disk I/O during writes
  /// - Cluster consensus delays
  /// - Network latency
  /// - Heavy server load
  ///
  /// Client action: Retry with exponential backoff. Consider increasing timeout values.
  /// Retriable - the operation may succeed on retry.
  case operationTimeout // = 6

  /// The server is starting up or shutting down and cannot process requests.
  ///
  /// Common causes:
  /// - Server is initializing (loading indexes, recovering state)
  /// - Server is performing graceful shutdown
  /// - Server is performing maintenance operations
  ///
  /// Client action: Retry with exponential backoff. Wait for server to become ready.
  /// Retriable - the server will become available after initialization completes.
  case serverNotReady // = 7

  /// The server is temporarily overloaded and cannot accept more requests.
  /// This is a backpressure mechanism to prevent server overload.
  ///
  /// Common causes:
  /// - Too many concurrent requests
  /// - Resource exhaustion (CPU, memory, disk I/O)
  /// - Rate limiting triggered
  ///
  /// Client action: Retry with exponential backoff. Reduce request rate.
  /// Retriable - the server may accept requests after load decreases.
  case serverOverloaded // = 8

  /// An internal server error occurred.
  /// This indicates a bug or unexpected condition in the server.
  ///
  /// Common causes:
  /// - Unhandled exceptions
  /// - Assertion failures
  /// - Corrupted internal state
  /// - Programming errors
  ///
  /// Client action: Report to server administrators with request details.
  /// May be retriable, but likely indicates a server-side issue requiring investigation.
  case serverMalfunction // = 9
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .accessDenied
    case 2: self = .badRequest
    case 5: self = .notLeaderNode
    case 6: self = .operationTimeout
    case 7: self = .serverNotReady
    case 8: self = .serverOverloaded
    case 9: self = .serverMalfunction
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .accessDenied: return 1
    case .badRequest: return 2
    case .notLeaderNode: return 5
    case .operationTimeout: return 6
    case .serverNotReady: return 7
    case .serverOverloaded: return 8
    case .serverMalfunction: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Kurrent_Rpc_ServerError] = [
    .unspecified,
    .accessDenied,
    .badRequest,
    .notLeaderNode,
    .operationTimeout,
    .serverNotReady,
    .serverOverloaded,
    .serverMalfunction,
  ]

}

/// Details for ACCESS_DENIED errors.
package struct Kurrent_Rpc_AccessDeniedErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The friendly name of the operation that was denied.
  package var operation: String = String()

  /// The username of the user who was denied access.
  package var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  package var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  package mutating func clearUsername() {self._username = nil}

  /// The permission that was required for this operation.
  package var permission: String {
    get {return _permission ?? String()}
    set {_permission = newValue}
  }
  /// Returns true if `permission` has been explicitly set.
  package var hasPermission: Bool {return self._permission != nil}
  /// Clears the value of `permission`. Subsequent reads from it will return its default value.
  package mutating func clearPermission() {self._permission = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _username: String? = nil
  fileprivate var _permission: String? = nil
}

/// Details for NOT_LEADER_NODE errors.
package struct Kurrent_Rpc_NotLeaderNodeErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information about the current cluster leader node.
  package var currentLeader: Kurrent_Rpc_NotLeaderNodeErrorDetails.NodeInfo {
    get {return _currentLeader ?? Kurrent_Rpc_NotLeaderNodeErrorDetails.NodeInfo()}
    set {_currentLeader = newValue}
  }
  /// Returns true if `currentLeader` has been explicitly set.
  package var hasCurrentLeader: Bool {return self._currentLeader != nil}
  /// Clears the value of `currentLeader`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentLeader() {self._currentLeader = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Information about a cluster node.
  package struct NodeInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hostname or IP address of the node.
    package var host: String = String()

    /// The gRPC port of the node.
    package var port: Int32 = 0

    /// The unique instance ID of the node.
    package var nodeID: String {
      get {return _nodeID ?? String()}
      set {_nodeID = newValue}
    }
    /// Returns true if `nodeID` has been explicitly set.
    package var hasNodeID: Bool {return self._nodeID != nil}
    /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
    package mutating func clearNodeID() {self._nodeID = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _nodeID: String? = nil
  }

  package init() {}

  fileprivate var _currentLeader: Kurrent_Rpc_NotLeaderNodeErrorDetails.NodeInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kurrent.rpc"

extension Kurrent_Rpc_ServerError: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED\0\u{1}SERVER_ERROR_ACCESS_DENIED\0\u{1}SERVER_ERROR_BAD_REQUEST\0\u{2}\u{3}SERVER_ERROR_NOT_LEADER_NODE\0\u{1}SERVER_ERROR_OPERATION_TIMEOUT\0\u{1}SERVER_ERROR_SERVER_NOT_READY\0\u{1}SERVER_ERROR_SERVER_OVERLOADED\0\u{1}SERVER_ERROR_SERVER_MALFUNCTION\0")
}

extension Kurrent_Rpc_AccessDeniedErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AccessDeniedErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}operation\0\u{1}username\0\u{1}permission\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._permission) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 1)
    }
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._permission {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrent_Rpc_AccessDeniedErrorDetails, rhs: Kurrent_Rpc_AccessDeniedErrorDetails) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs._username != rhs._username {return false}
    if lhs._permission != rhs._permission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrent_Rpc_NotLeaderNodeErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NotLeaderNodeErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_leader\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentLeader) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentLeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrent_Rpc_NotLeaderNodeErrorDetails, rhs: Kurrent_Rpc_NotLeaderNodeErrorDetails) -> Bool {
    if lhs._currentLeader != rhs._currentLeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrent_Rpc_NotLeaderNodeErrorDetails.NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Kurrent_Rpc_NotLeaderNodeErrorDetails.protoMessageName + ".NodeInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}host\0\u{1}port\0\u{3}node_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._nodeID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 2)
    }
    try { if let v = self._nodeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrent_Rpc_NotLeaderNodeErrorDetails.NodeInfo, rhs: Kurrent_Rpc_NotLeaderNodeErrorDetails.NodeInfo) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
