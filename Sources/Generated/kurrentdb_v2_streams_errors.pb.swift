// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kurrentdb/v2/streams/errors.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ******************************************************************************************
// This protocol is UNSTABLE in the sense of being subject to change.
// ******************************************************************************************

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Error codes specific to the Streams API.
/// These errors represent failure modes when working with streams of records.
package enum Kurrentdb_Protocol_V2_Streams_Errors_StreamsError: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Default value. This value is not used.
  /// An error code MUST always be set to a non-zero value.
  /// If an error code is not explicitly set, it MUST be treated as
  /// an internal server error (INTERNAL).
  case unspecified // = 0

  /// The requested stream does not exist in the database.
  ///
  /// Common causes:
  /// - Stream name typo or incorrect stream identifier
  /// - Stream was never created (no events appended yet)
  /// - Stream was deleted and not yet recreated
  ///
  /// Client action: Verify the stream name is correct. Create the stream by appending to it.
  /// Recoverable by creating the stream first (append with NO_STREAM expected revision).
  case streamNotFound // = 1

  /// The stream already exists when an operation expected it not to exist.
  ///
  /// Common causes:
  /// - Attempting to create a stream that already has events
  /// - Using NO_STREAM expected revision on an existing stream
  /// - Race condition with concurrent stream creation
  ///
  /// Client action: Use the existing stream or use a different expected revision.
  /// Recoverable by adjusting the expected revision or using the existing stream.
  case streamAlreadyExists // = 2

  /// The stream has been soft deleted.
  /// Soft-deleted streams are hidden from stream lists but can be restored by appending to them.
  ///
  /// Common causes:
  /// - Stream was explicitly soft-deleted via delete operation
  /// - Attempting to read from a soft-deleted stream
  ///
  /// Client action: Restore the stream by appending new events, or accept that the stream is deleted.
  /// Recoverable by appending to the stream to restore it.
  case streamDeleted // = 3

  /// The stream has been tombstoned (permanently deleted).
  /// Tombstoned streams cannot be restored and will never accept new events.
  ///
  /// Common causes:
  /// - Stream was explicitly tombstoned via tombstone operation
  /// - Administrative deletion of sensitive data
  /// - Attempting to write to or read from a tombstoned stream
  ///
  /// Client action: Stream is permanently removed. Create a new stream with a different name if needed.
  /// Not recoverable - the stream cannot be restored.
  case streamTombstoned // = 4

  /// The expected revision does not match the actual stream revision.
  /// This is an optimistic concurrency control failure.
  ///
  /// Common causes:
  /// - Another client modified the stream concurrently
  /// - Client has stale state about the stream revision
  /// - Race condition in distributed system
  ///
  /// Client action: Fetch the current stream revision and retry with the correct expected revision.
  /// Recoverable by reading the current state and retrying with proper optimistic concurrency control.
  case streamRevisionConflict // = 5

  /// A single record being appended exceeds the maximum allowed size.
  ///
  /// Common causes:
  /// - Record payload is too large (exceeds server's max record size configuration)
  /// - Excessive metadata in properties
  /// - Large binary data without chunking
  ///
  /// Client action: Reduce record size, split large payloads across multiple records, or increase server limits.
  /// Recoverable by reducing record size or adjusting server configuration.
  case appendRecordSizeExceeded // = 6

  /// The total size of all records in a single append session exceeds the maximum allowed transaction size.
  ///
  /// Common causes:
  /// - Too many records in a single append session
  /// - Combined payload size exceeds server's max transaction size
  /// - Attempting to write very large batches
  ///
  /// Client action: Split the append into multiple smaller transactions.
  /// Recoverable by reducing the number of records per append session.
  case appendTransactionSizeExceeded // = 7

  /// The same stream appears multiple times in a single append session.
  /// This is currently not supported to prevent complexity with expected revisions and ordering.
  ///
  /// Common causes:
  /// - Accidentally appending to the same stream twice in one session
  /// - Application logic error in batch operations
  ///
  /// Client action: Remove duplicate streams from the append session or split into multiple sessions.
  /// Recoverable by restructuring the append session to reference each stream only once.
  case streamAlreadyInAppendSession // = 8

  /// An append session was started but no append requests were sent before completing the stream.
  ///
  /// Common causes:
  /// - Client completed the stream without sending any AppendRequest messages
  /// - Application logic error
  ///
  /// Client action: Ensure at least one AppendRequest is sent before completing the stream.
  /// Recoverable by properly implementing the append session protocol.
  case appendSessionNoRequests // = 9
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .streamNotFound
    case 2: self = .streamAlreadyExists
    case 3: self = .streamDeleted
    case 4: self = .streamTombstoned
    case 5: self = .streamRevisionConflict
    case 6: self = .appendRecordSizeExceeded
    case 7: self = .appendTransactionSizeExceeded
    case 8: self = .streamAlreadyInAppendSession
    case 9: self = .appendSessionNoRequests
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .streamNotFound: return 1
    case .streamAlreadyExists: return 2
    case .streamDeleted: return 3
    case .streamTombstoned: return 4
    case .streamRevisionConflict: return 5
    case .appendRecordSizeExceeded: return 6
    case .appendTransactionSizeExceeded: return 7
    case .streamAlreadyInAppendSession: return 8
    case .appendSessionNoRequests: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Kurrentdb_Protocol_V2_Streams_Errors_StreamsError] = [
    .unspecified,
    .streamNotFound,
    .streamAlreadyExists,
    .streamDeleted,
    .streamTombstoned,
    .streamRevisionConflict,
    .appendRecordSizeExceeded,
    .appendTransactionSizeExceeded,
    .streamAlreadyInAppendSession,
    .appendSessionNoRequests,
  ]

}

/// Details for STREAM_NOT_FOUND errors.
package struct Kurrentdb_Protocol_V2_Streams_Errors_StreamNotFoundErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the stream that was not found.
  package var stream: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Details for STREAM_ALREADY_EXISTS errors.
package struct Kurrentdb_Protocol_V2_Streams_Errors_StreamAlreadyExistsErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the stream that already exists.
  package var stream: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Details for STREAM_DELETED errors.
package struct Kurrentdb_Protocol_V2_Streams_Errors_StreamDeletedErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the stream that was deleted.
  package var stream: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Details for STREAM_TOMBSTONED errors.
package struct Kurrentdb_Protocol_V2_Streams_Errors_StreamTombstonedErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the stream that was tombstoned.
  package var stream: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Details for STREAM_REVISION_CONFLICT errors.
package struct Kurrentdb_Protocol_V2_Streams_Errors_StreamRevisionConflictErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the stream that had a revision conflict.
  package var stream: String = String()

  /// The expected revision that was provided in the append request.
  package var expectedRevision: Int64 = 0

  /// The actual current revision of the stream.
  package var actualRevision: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Details for APPEND_RECORD_SIZE_EXCEEDED errors.
package struct Kurrentdb_Protocol_V2_Streams_Errors_AppendRecordSizeExceededErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the stream where the append was attempted.
  package var stream: String = String()

  /// The identifier of the record that exceeded the size limit.
  package var recordID: String = String()

  /// The actual size of the record in bytes.
  package var size: Int32 = 0

  /// The maximum allowed size of a single record in bytes.
  package var maxSize: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Details for APPEND_TRANSACTION_SIZE_EXCEEDED errors.
package struct Kurrentdb_Protocol_V2_Streams_Errors_AppendTransactionSizeExceededErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The actual size of the transaction in bytes.
  package var size: Int32 = 0

  /// The maximum allowed size of an append transaction in bytes.
  package var maxSize: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Details for STREAM_ALREADY_IN_APPEND_SESSION errors.
package struct Kurrentdb_Protocol_V2_Streams_Errors_StreamAlreadyInAppendSessionErrorDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the stream that appears multiple times.
  package var stream: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kurrentdb.protocol.v2.streams.errors"

extension Kurrentdb_Protocol_V2_Streams_Errors_StreamsError: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0STREAMS_ERROR_UNSPECIFIED\0\u{1}STREAMS_ERROR_STREAM_NOT_FOUND\0\u{1}STREAMS_ERROR_STREAM_ALREADY_EXISTS\0\u{1}STREAMS_ERROR_STREAM_DELETED\0\u{1}STREAMS_ERROR_STREAM_TOMBSTONED\0\u{1}STREAMS_ERROR_STREAM_REVISION_CONFLICT\0\u{1}STREAMS_ERROR_APPEND_RECORD_SIZE_EXCEEDED\0\u{1}STREAMS_ERROR_APPEND_TRANSACTION_SIZE_EXCEEDED\0\u{1}STREAMS_ERROR_STREAM_ALREADY_IN_APPEND_SESSION\0\u{1}STREAMS_ERROR_APPEND_SESSION_NO_REQUESTS\0")
}

extension Kurrentdb_Protocol_V2_Streams_Errors_StreamNotFoundErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StreamNotFoundErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stream\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stream) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stream.isEmpty {
      try visitor.visitSingularStringField(value: self.stream, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamNotFoundErrorDetails, rhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamNotFoundErrorDetails) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_V2_Streams_Errors_StreamAlreadyExistsErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StreamAlreadyExistsErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stream\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stream) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stream.isEmpty {
      try visitor.visitSingularStringField(value: self.stream, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamAlreadyExistsErrorDetails, rhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamAlreadyExistsErrorDetails) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_V2_Streams_Errors_StreamDeletedErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StreamDeletedErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stream\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stream) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stream.isEmpty {
      try visitor.visitSingularStringField(value: self.stream, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamDeletedErrorDetails, rhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamDeletedErrorDetails) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_V2_Streams_Errors_StreamTombstonedErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StreamTombstonedErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stream\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stream) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stream.isEmpty {
      try visitor.visitSingularStringField(value: self.stream, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamTombstonedErrorDetails, rhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamTombstonedErrorDetails) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_V2_Streams_Errors_StreamRevisionConflictErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StreamRevisionConflictErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stream\0\u{3}expected_revision\0\u{3}actual_revision\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stream) }()
      case 2: try { try decoder.decodeSingularSInt64Field(value: &self.expectedRevision) }()
      case 3: try { try decoder.decodeSingularSInt64Field(value: &self.actualRevision) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stream.isEmpty {
      try visitor.visitSingularStringField(value: self.stream, fieldNumber: 1)
    }
    if self.expectedRevision != 0 {
      try visitor.visitSingularSInt64Field(value: self.expectedRevision, fieldNumber: 2)
    }
    if self.actualRevision != 0 {
      try visitor.visitSingularSInt64Field(value: self.actualRevision, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamRevisionConflictErrorDetails, rhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamRevisionConflictErrorDetails) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.expectedRevision != rhs.expectedRevision {return false}
    if lhs.actualRevision != rhs.actualRevision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_V2_Streams_Errors_AppendRecordSizeExceededErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AppendRecordSizeExceededErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stream\0\u{3}record_id\0\u{1}size\0\u{3}max_size\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stream) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recordID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.maxSize) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stream.isEmpty {
      try visitor.visitSingularStringField(value: self.stream, fieldNumber: 1)
    }
    if !self.recordID.isEmpty {
      try visitor.visitSingularStringField(value: self.recordID, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 3)
    }
    if self.maxSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_V2_Streams_Errors_AppendRecordSizeExceededErrorDetails, rhs: Kurrentdb_Protocol_V2_Streams_Errors_AppendRecordSizeExceededErrorDetails) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.recordID != rhs.recordID {return false}
    if lhs.size != rhs.size {return false}
    if lhs.maxSize != rhs.maxSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_V2_Streams_Errors_AppendTransactionSizeExceededErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AppendTransactionSizeExceededErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}size\0\u{3}max_size\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxSize) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.maxSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_V2_Streams_Errors_AppendTransactionSizeExceededErrorDetails, rhs: Kurrentdb_Protocol_V2_Streams_Errors_AppendTransactionSizeExceededErrorDetails) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.maxSize != rhs.maxSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kurrentdb_Protocol_V2_Streams_Errors_StreamAlreadyInAppendSessionErrorDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StreamAlreadyInAppendSessionErrorDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}stream\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stream) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stream.isEmpty {
      try visitor.visitSingularStringField(value: self.stream, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamAlreadyInAppendSessionErrorDetails, rhs: Kurrentdb_Protocol_V2_Streams_Errors_StreamAlreadyInAppendSessionErrorDetails) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
