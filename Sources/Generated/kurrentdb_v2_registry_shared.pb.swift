// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kurrentdb/v2/registry/shared.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents the format of the schema data.
package enum Kurrentdb_Protocol_Registry_V2_SchemaDataFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Default value, should not be used.
  case unspecified // = 0

  /// application/json
  case json // = 1

  /// application/vnd.google.protobuf
  case protobuf // = 2

  /// application/vnd.apache.avro+json
  case avro // = 3

  /// application/octet-stream
  case bytes // = 4
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .json
    case 2: self = .protobuf
    case 3: self = .avro
    case 4: self = .bytes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .json: return 1
    case .protobuf: return 2
    case .avro: return 3
    case .bytes: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Kurrentdb_Protocol_Registry_V2_SchemaDataFormat] = [
    .unspecified,
    .json,
    .protobuf,
    .avro,
    .bytes,
  ]

}

/// Schema compatibility modes define how schema changes are validated against previous versions.
package enum Kurrentdb_Protocol_Registry_V2_CompatibilityMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Default value, should not be used.
  case unspecified // = 0

  /// Backward compatibility allows new schemas to be used with data written by previous schemas.
  /// Example: If schema version 1 has a field "name" and schema version 2 adds a new field "age",
  /// data written with schema version 1 can still be read using schema version 2.
  /// Example of invalid schema: If schema version 1 has a field "name" and schema version 2 removes the "name" field,
  /// data written with schema version 1 cannot be read using schema version 2.
  case backward // = 1

  /// Forward compatibility allows data written by new schemas to be read by previous schemas.
  /// Example: If schema version 1 has a field "name" and schema version 2 adds a new field "age",
  /// data written with schema version 2 can still be read using schema version 1, ignoring the "age" field.
  /// Example of invalid schema: If schema version 1 has a field "name" and schema version 2 changes the "name" field type,
  /// data written with schema version 2 cannot be read using schema version 1.
  case forward // = 2

  /// Full compatibility ensures both backward and forward compatibility.
  /// This mode guarantees that new schemas can read data written by old schemas,
  /// and old schemas can read data written by new schemas.
  case full // = 3

  /// Backward All compatibility ensures new schemas can read data written by ALL previous schema versions,
  /// not just the immediately preceding one.
  case backwardAll // = 4

  /// Forward All compatibility ensures ALL previous schema versions can read data written by new schemas.
  /// This provides stronger guarantees than regular forward compatibility.
  case forwardAll // = 5

  /// Full All compatibility combines backward all and forward all compatibility modes.
  /// This ensures complete compatibility across all schema versions, providing the strongest compatibility guarantees.
  case fullAll // = 6

  /// Disables compatibility checks, allowing any kind of schema change.
  /// This mode should be used with caution, as it may lead to compatibility issues.
  case none // = 7
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .backward
    case 2: self = .forward
    case 3: self = .full
    case 4: self = .backwardAll
    case 5: self = .forwardAll
    case 6: self = .fullAll
    case 7: self = .none
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .backward: return 1
    case .forward: return 2
    case .full: return 3
    case .backwardAll: return 4
    case .forwardAll: return 5
    case .fullAll: return 6
    case .none: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Kurrentdb_Protocol_Registry_V2_CompatibilityMode] = [
    .unspecified,
    .backward,
    .forward,
    .full,
    .backwardAll,
    .forwardAll,
    .fullAll,
    .none,
  ]

}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Kurrentdb_Protocol_Registry_V2_SchemaDataFormat: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SCHEMA_DATA_FORMAT_UNSPECIFIED\0\u{1}SCHEMA_DATA_FORMAT_JSON\0\u{1}SCHEMA_DATA_FORMAT_PROTOBUF\0\u{1}SCHEMA_DATA_FORMAT_AVRO\0\u{1}SCHEMA_DATA_FORMAT_BYTES\0")
}

extension Kurrentdb_Protocol_Registry_V2_CompatibilityMode: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0COMPATIBILITY_MODE_UNSPECIFIED\0\u{1}COMPATIBILITY_MODE_BACKWARD\0\u{1}COMPATIBILITY_MODE_FORWARD\0\u{1}COMPATIBILITY_MODE_FULL\0\u{1}COMPATIBILITY_MODE_BACKWARD_ALL\0\u{1}COMPATIBILITY_MODE_FORWARD_ALL\0\u{1}COMPATIBILITY_MODE_FULL_ALL\0\u{1}COMPATIBILITY_MODE_NONE\0")
}
